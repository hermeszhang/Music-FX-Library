% Kunal Jathal
%

% Chorus function using LFO and an All Pass Filter for fractional delay
% =====================================================================

% We want to implement a FRACTIONAL delay chorus filter

% y[n] = x[n] + b0 * x[n - g[n]]

% We want to take in the following arguments:
% Delay Coefficient (b0)
% Input Signal (x[n])
% Delay Amount (g[n]) - this is now a function of time. So we use an LFO to
% vary it with time. Hence 3 new variables introduced are:
% a) LFO Frequency
% b) Minimum delay in MILLISECONDS
% c) Maximum delay in MILLISECONDS

% The difference here now is in the indices retrieved by the LFO.
% Previously, we rounded to the nearest integer sample number. In this case,
% we don't round, and instead construct the sample that the LFO tells us to
% retrieve.


function allPassChorus(input, delayCoefficient, minDelay, maxDelay, LFOfrequency)


% Read in audio file
[inputSignal, fs] = wavread(input);

% Play it
sound(inputSignal, fs);

% Convert delays to samples
minDelay = round((minDelay/1000) * fs);
maxDelay = round((maxDelay/1000) * fs);

% We create a buffer to hold the delayed samples that we will need to
% access when building the new signal. The number of samples the buffer
% should be able to hold should be equal to the maximum delay desired.
buffer = zeros(1, maxDelay);

% Create empty output signal
outputSignal = zeros(1,length(inputSignal));

% When accessing the buffer, we need to know which sample to get. Since the
% minimum delay is specified, we know that the sample we need will be the
% minimum delay + the amount specified by the LFO. So the start index will
% always be at least the minimum delay, and we will add this start index to
% the index generated by the LFO to get the buffer index of the sample we
% wish to retrieve.
startIndex = minDelay;
lfoTable = abs(sin(2*pi*LFOfrequency*[0:length(inputSignal)-1]/fs));
bufferIndex = lfoTable*(length(buffer)-startIndex) + startIndex;

% Create the output signal now by constructing it sample by sample
for i=1:length(inputSignal) 
    % We split the sample retrieved by the LFO (bufferIndex) into it's
    % integer and mantissa parts.
    bufferInteger = floor(bufferIndex(i));
    bufferMantissa = bufferIndex(i) - bufferInteger;
    
    % If the LFO retrieves an integer sample, we don't need to worry
    if (bufferMantissa == 0)
        newSample = buffer(bufferIndex(i));
    else
        % If we have a fractional sample number, we use an all pass filter to
        % generate the fractional delay. First, we need to calculate a value of
        % alpha that corresponds to the fractional delay required.

        % From my math (which I'm hoping is right), I get the following
        % equation for alpha:
        %
        % alpha = (1 + K) / (1 - K)
        %
        % where
        %
        % K = tan(phi/2) / tan (theta/2)
        %
        % where phi = samples (delay) * radians/sample (theta)
        %
        % For the value of theta, I have used the average (0.5 pi)
        %
        % Now we build an all pass filter with this value of alpha    

        theta = 0.5 * pi;
        phi = -1 * bufferMantissa * theta;
        K = tan(phi/2) / tan(theta/2);        
        alpha = (1 + K)/(1 - K);

        % We use the all pass filter with this value of alpha to filter the
        % integer sample in order to generate the fractional delayed sample.
        % Note than an all pass filter has the following difference equation:
        %
        % y[n] = alpha.x[n] + x[n - 1] - alpha.y[n - 1]

        newSample = filter([alpha 1],[1 alpha], buffer(bufferInteger));
    end
    
    outputSignal(i) = inputSignal(i) + (delayCoefficient * newSample);

    % Update the buffer as we move forward in time
    buffer(2:end) = buffer(1:end-1);
    buffer(1) = inputSignal(i);
end

% Let's hear our chorus!
sound(outputSignal, fs)

end


% Some of the problems using the all pass filter for the fractional delay
% are:

% The accuracy of the fractional delay is a function of frequency. One of
% the problems is that, we use an average frequency value to calculate the
% corresponding alpha value to build our all pass filter with. This does
% not accurately represent the true frequency content of the input signal.
% For example, if the input is a bass guitar sound, it would make sense to
% have chosen a lower theta, corresponding to a more accurate delay (alpha)
% value. Another problem is that, the fractional delay itself is not linear
% for values of alpha. In particular, for higher frequencies, the delay
% becomes more and more non-linear as we get closer to the Nyquist
% frequency, especially for higher values of alpha. This means that not all
% frequencies (in particular the high ones) will be fractionally delayed
% uniformly. This basically results in a group delay, which results in a
% bit of audible distortion.